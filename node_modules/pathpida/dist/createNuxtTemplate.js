"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs_1 = __importDefault(require("fs"));
var path_1 = __importDefault(require("path"));
var isIgnored_1 = require("./isIgnored");
var parseQueryFromTS_1 = require("./parseQueryFromTS");
var replaceWithUnderscore_1 = require("./replaceWithUnderscore");
var createMethods = function (indent, importName, pathname, trailingSlash) {
    return indent + "  $url: (url" + ((importName === null || importName === void 0 ? void 0 : importName.startsWith('Query')) ? '' : '?') + ": { " + (importName ? "query" + (importName.startsWith('Optional') ? '?' : '') + ": " + importName + ", " : '') + "hash?: string }) => ({ path: " + (/\${/.test(pathname) ? '`' : "'") + pathname + (trailingSlash || pathname === '' ? '/' : '') + (/\${/.test(pathname) ? '`' : "'") + (importName ? ", query: url" + (importName.startsWith('Query') ? '' : '?') + ".query as any" : '') + ", hash: url" + ((importName === null || importName === void 0 ? void 0 : importName.startsWith('Query')) ? '' : '?') + ".hash })";
};
var parseQueryFromVue = function (file, suffix) {
    var fileData = fs_1.default.readFileSync(file, 'utf8');
    var typeName = ['Query', 'OptionalQuery'].find(function (type) {
        return new RegExp("export (interface " + type + " ?{|type " + type + " ?= ?{)").test(fileData);
    });
    if (!typeName)
        return;
    var queryRegExp = new RegExp("export (interface " + typeName + " ?{|type " + typeName + " ?= ?{)");
    var _a = __read(fileData.split(queryRegExp), 3), typeText = _a[1], targetText = _a[2];
    var length = targetText.length;
    var cursor = 0;
    var depth = 1;
    while (depth && cursor <= length) {
        if (targetText[cursor] === '}') {
            depth -= 1;
        }
        else if (targetText[cursor] === '{') {
            depth += 1;
        }
        cursor += 1;
    }
    var importName = "" + typeName + suffix;
    return {
        importName: importName,
        importString: "" + typeText.replace(typeName, importName) + targetText
            .slice(0, cursor)
            .replace(/\r/g, '') + "\n"
    };
};
exports.default = (function (input, output, ignorePath, trailingSlash) {
    if (trailingSlash === void 0) { trailingSlash = false; }
    var ig = (0, isIgnored_1.createIg)(ignorePath);
    var imports = [];
    var getImportName = function (file) {
        var result = path_1.default.extname(file).startsWith('.ts')
            ? (0, parseQueryFromTS_1.parseQueryFromTS)(output, file, imports.length)
            : parseQueryFromVue(file, imports.length);
        if (result) {
            imports.push(result.importString);
            return result.importName;
        }
    };
    var createPathObjString = function (targetDir, importBasePath, indent, url, text, methodsOfIndexTsFile) {
        indent += '  ';
        var props = fs_1.default
            .readdirSync(targetDir)
            .filter(function (file) {
            return [
                !file.startsWith('-'),
                !/\.s?css$/.test(file),
                !file.endsWith('.d.ts'),
                !(0, isIgnored_1.isIgnored)(ig, ignorePath, targetDir, file)
            ].every(Boolean);
        })
            .sort()
            .map(function (file, _, arr) {
            var basename = path_1.default.basename(file, path_1.default.extname(file));
            var valFn = "" + indent + (0, replaceWithUnderscore_1.replaceWithUnderscore)(basename) + ": {\n<% next %>\n" + indent + "}";
            var newUrl = url + "/" + basename;
            if (basename.startsWith('_')) {
                var slug = basename.slice(1);
                var isPassValNullable = basename !== file;
                valFn = indent + "_" + slug + ": (" + slug + (isPassValNullable ? '?' : '') + ": string | number) => ({\n<% next %>\n" + indent + "})";
                newUrl = "" + url + (isPassValNullable ? "${" + slug + " !== undefined ? `/${" + slug + "}` : ''}" : "/${" + slug + "}");
            }
            var target = path_1.default.posix.join(targetDir, file);
            if (fs_1.default.statSync(target).isFile() && basename !== 'index' && !arr.includes(basename)) {
                return valFn.replace('<% next %>', createMethods(indent, getImportName(target), newUrl, trailingSlash));
            }
            else if (fs_1.default.statSync(target).isDirectory()) {
                var indexFile = fs_1.default
                    .readdirSync(target)
                    .find(function (name) { return path_1.default.basename(name, path_1.default.extname(name)) === 'index'; });
                return createPathObjString(target, importBasePath + "/" + file, indent, newUrl, valFn.replace('<% next %>', '<% props %>'), indexFile &&
                    createMethods(indent, getImportName(path_1.default.posix.join(target, indexFile)), newUrl, trailingSlash));
            }
            return '';
        })
            .filter(Boolean);
        return text.replace('<% props %>', "" + props.join(',\n') + (methodsOfIndexTsFile ? "" + (props.length ? ',\n' : '') + methodsOfIndexTsFile : ''));
    };
    var rootIndexFile = fs_1.default
        .readdirSync(input)
        .find(function (name) { return path_1.default.basename(name, path_1.default.extname(name)) === 'index'; });
    var rootIndent = '';
    var rootMethods;
    if (rootIndexFile) {
        rootMethods = createMethods(rootIndent, getImportName(path_1.default.posix.join(input, rootIndexFile)), '', trailingSlash);
    }
    var text = createPathObjString(input, '.', rootIndent, '', "{\n<% props %>\n}", rootMethods);
    var importsText = imports.filter(function (i) { return i.startsWith('import'); }).join('\n');
    var queriesText = imports.filter(function (i) { return !i.startsWith('import'); }).join('\n');
    return "import type { Plugin } from '@nuxt/types'\n" + importsText + (importsText && queriesText ? '\n' : '') + "\n" + queriesText + (imports.length ? '\n' : '') + "export const pagesPath = " + text + "\n\nexport type PagesPath = typeof pagesPath\n";
});
//# sourceMappingURL=createNuxtTemplate.js.map